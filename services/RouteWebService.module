<?php
/**
 * Created by JetBrains PhpStorm.
 * User: Anton
 * Date: 04.04.15
 * Time: 22:27
 * To change this template use File | Settings | File Templates.
 */
require_once("WebServBase.module");
require_once("Headers.module");
require_once("Contract.module");
require_once("GeoRouteHelper.module");
require_once("RouteHelper.module");


class RouteWebService extends WebServBase
{

    public function onGet($args)
    {

        /*
         * Возвращаем список выбранных задач для пользователя
         *
         * */


        $accountId = null;
        $userTokenId = null;
        CurrentUser::FillUserIdentities($accountId, $userTokenId);

        // возвращаем объекты AjaxTask
        $db = SqlFactory::getSql();

        try
        {
            $page_arg = intval($args[0]);
            $page = $page_arg > 0 ? $page_arg : 1;

            // TODO Сделать проверку правильности номера страницы полученного с клиента

            $limit = 20;
            $offset = ($page - 1) * $limit;
            $allRowCount = 0;

            if(is_null($accountId))
                $where_sql_definition = $db->parse(' CS.user_token_id = ?i ', $userTokenId);
            else
                $where_sql_definition = $db->parse(' CS.account_id = ?i ', $accountId);


            // получаем количество записей удовлетворяющих условию фильтрации
            $sql = 'SELECT count(C.id)
                    FROM cargo C
                      INNER JOIN cargo_selected CS
                            ON CS.cargo_id = C.id
                              AND ?p
                    WHERE C.is_deleted = 0';

            $allRowCount = $db->getOne($sql, $where_sql_definition);


            $sql = 'SELECT DISTINCT C.id, GC1.name AS city1, GC2.name AS city2, CT.name AS type,
                          C.weight, C.value, C.distance, C.cost, C.ready_date, CS.id AS selectedId, RP.cargo_selected_id AS route_point_cargo_selected_id
                    FROM cargo C
                        INNER JOIN geocities GC1
                            ON GC1.id = C.city1_id
                        INNER JOIN geocities GC2
                            ON GC2.id = C.city2_id
                        INNER JOIN cargo_type CT
                            ON CT.id = C.cargo_type_id
                        INNER JOIN cargo_selected CS
                            ON CS.cargo_id = C.id
                              AND ?p
                        LEFT OUTER JOIN route_point RP
                            ON RP.cargo_selected_id = CS.id
                    WHERE C.is_deleted = 0';

            $result = $db->query($sql, $where_sql_definition);
            $arr = array();

            if(0 < $db->numRows($result))
            {
                while($row = $db->fetch($result))
                {
                    $rusReadyDate = Validators::convertMySqlDate2RusDate($row['ready_date']);
                    $selected = intval($row['route_point_cargo_selected_id']) > 0;

                    $entry = new AjaxTask
                    (
                        $row['id'], $row['city1'], $row['city2'], $row['type'], $row['weight'], $row['value'], $row['distance'], $row['cost'], $rusReadyDate, $selected, $row['selectedId']
                    );

                    array_push($arr, $entry);
                }
            }

            // на данный момент информацию о страницах не заполняем, т.к. возвращаем все данные
            $respData = new AjaxTaskList();
            $respData->offset = $offset;
            $respData->limit = $limit;
            $respData->allRowCount = $allRowCount;
            $respData->page = $page;
            $respData->tasks = $arr;

            $response = new AjaxServerResponse(200, '', '', $respData);
            sendHTTPStatus(200);
            header('Content-type: application/json');
            echo json_encode($response);

        }
        catch(Exception $ex)
        {
            Log::writeSqlExeption($db, $ex);
            $this->returnError(500, array(1));
        }

    }

    // Добавляем новую задачу в маршрут
    public function onPost($args, $data)
    {
        // $data = AjaxIdsList

        $idsInSqlString = implode(',', $data->ids);

        $accountId = null;
        $userTokenId = null;
        CurrentUser::FillUserIdentities($accountId, $userTokenId);


        $db = SqlFactory::getSql();

        try
        {
            if(is_null($accountId))
                $where_sql_definition = $db->parse(' AND CS.user_token_id = ?i ', $userTokenId);
            else
                $where_sql_definition = $db->parse(' AND CS.account_id = ?i ', $accountId);

            // 1. получаем уникальный список переданных грузов - страхуемся от неверных данных и дублей
            $sql = 'SELECT DISTINCT CS.id, CS.cargo_id, C.city1_id, C.city2_id
                    FROM cargo_selected CS
                        INNER JOIN cargo C
                            ON C.id = CS.cargo_id
                    WHERE CS.cargo_id IN (?p) ?p';

            $result = $db->query($sql, $idsInSqlString, $where_sql_definition);
            $arr_cargo = array();

            if(0 < $db->numRows($result))
            {
                // 2. модифицируем список переданных идентификаторов - вносим только корректные идентификаторы
                $data->ids = array();

                while($row = $db->fetch($result))
                {
                    array_push($data->ids, $row['cargo_id']);
                    $entry = new AjaxTaskShort($row['id'], $row['city1_id'], $row['city2_id']);
                    array_push($arr_cargo, $entry);
                }
            }

            // 3. если в результате не оказалось указанных грузов, то возвращаем ошибку
            if(1 > count($arr_cargo))
            {
                $this->returnError(400, array(1014), $data);
                return;
            }


            $max_order = 0;
            $lastCityId = 0;

            // 4. проверяем, создан ли маршрут и при необходимости создаём его
            $route_id = RouteHelper::GetRouteId($accountId, $userTokenId, $db);

            if(false == $route_id)
            {
                // создаём запись маршрута в БД
                $route_id = RouteHelper::CreateRoute($accountId, $userTokenId, $db);
            }
            else
            {
                // 5. если маршрут уже есть в БД, то проверяем переданные задания на повтор - содержатся ли указанные грузы в маршруте
                $idsInSqlString = implode(',', $data->ids);

                $sql = 'SELECT count(*) FROM route_point
                        WHERE route_id = ?i AND cargo_selected_id IN(?p)';

                $repeats_num = $db->getOne($sql, $route_id, $idsInSqlString);

                // 6. если указанные грузы уже есть в маршруте, то возвращаем ошибку
                if(0 < $repeats_num)
                {
                    $this->returnError(400, array(1015), $data);
                    return;
                }

                // 7. получаем данные последней точки в маршруте
                $sql = 'SELECT city_id, order_num
                        FROM route_point
                        WHERE route_id = ?i
                        ORDER BY order_num DESC
                        LIMIT 1';

                $result = $db->query($sql, $route_id);

                if(0 < $db->numRows($result))
                {
                    $row = $db->fetch($result);
                    $max_order = $row['order_num'];
                    $lastCityId = $row['city_id'];
                }
            }


            // 8. получаем все расстояния между городами в добавляемых точках маршрута

            // 8.1 формируем список городов
            $arr_cities = array();
            array_push($arr_cities, $lastCityId);

            foreach ($arr_cargo as $cargo)
            {
                array_push($arr_cities, $cargo->city1);
                array_push($arr_cities, $cargo->city2);
            }

            // 8.2 получаем список дистанций между городами
            $distanceList = GeoRouteHelper::GetDistanceList($arr_cities, $db);

            // 9. вносим все задачи в маршрут
            $max_order++;

            // ... шаблон запроса
            $sql = 'INSERT INTO route_point (route_id, cargo_selected_id, city_id, distance, is_first_point_of_pair, order_num)
                        VALUES (?i, ?i, ?i, ?i, ?i, ?i)';

            for ($i = 0; $i < count($arr_cargo); $i++)
            {
                $cargo = $arr_cargo[$i];

                $distance = $distanceList->GetDistanceFromList($lastCityId, $cargo->city1);
                $db->query($sql, $route_id, $cargo->id, $cargo->city1, $distance, 1, $max_order++);

                $distance = $distanceList->GetDistanceFromList($cargo->city1, $cargo->city2);
                $db->query($sql, $route_id, $cargo->id, $cargo->city2, $distance, 0, $max_order++);

                $lastCityId = $cargo->city2;
            }

            // 10. Получаем обновлённый маршрут
            $routePointList = CalculateRouteWebService::GetRouteData($accountId, $userTokenId, $db);

            // 11. Возвращаем ответ клиенту
            $responseData = new AjaxIdsListAndRoutePointList();
            $responseData->idsList = $data;
            $responseData->routePointList = $routePointList;
            $response = new AjaxServerResponse(200, '', '', $responseData);
            sendHTTPStatus(200);
            header('Content-type: application/json');
            echo json_encode($response);

        }
        catch(Exception $ex)
        {
            Log::writeSqlExeption($db, $ex);
            $this->returnError(500, array(1), $data);
        }
    }

    public function onPut($args, $data)
    {
        // AjaxRoutePointPlace

        // TODO: редактируем порядок маршрутных точек

        $accountId = null;
        $userTokenId = null;
        CurrentUser::FillUserIdentities($accountId, $userTokenId);


        $db = SqlFactory::getSql();

        try
        {
            // 1. получаем id маршрута для пользователя
            $route_id = RouteHelper::GetRouteId($accountId, $userTokenId, $db);

            if(false == $route_id)
            {
                // возвращаем ошибку
                $this->returnError(400, array(1014), $data);
                return;
            }

            $routePointId = $data->routePointId;
            $afterRoutePointId = $data->afterRoutePointId;

            // 2. проверяем, что переданные точки маршрута принадлежат маршруту пользователя
            $pointIds = array();
            array_push($pointIds, $routePointId);

            if(! is_null($afterRoutePointId))
                array_push($pointIds, $afterRoutePointId);

            $arePointsInRoute = RouteHelper::AreAllPointsInRoute($route_id, $pointIds, $db);

            if(false == $arePointsInRoute)
            {
                // возвращаем ошибку
                $this->returnError(400, array(1014), $data);
                return;
            }

            // 3. получаем данные маршрута
            $routePoints = RouteHelper::GetRouteData($route_id, $db);

            // 4. проверяем, что новая позиция точки маршрута не меняет направление маршрута - первая точка маршрута в списке должна находиться перед второй точкой маршрута
            $isValidPosition = RouteHelper::CheckIfRoutePointPositionInArrayIsCorrect($routePointId, $afterRoutePointId, $routePoints);

            if(false == $isValidPosition)
            {
                // возвращаем ошибку
                $this->returnError(400, array(1016), $data);
                return;
            }

            // 5. меняем порядок точек маршрута
            $routePoints = RouteHelper::ChangeRoutePointPositionInArray($routePointId, $afterRoutePointId, $routePoints);

            // 6. пересчитываем дистанции маршрута
            // ... 6.1 получаем список дистанций между городами
            $arr_cities = RouteHelper::GetUniqueCitiesFromRoutePointsArray($routePoints);
            $distanceList = GeoRouteHelper::GetDistanceList($arr_cities, $db);

            // ... 6.2 пересчитываем дистанции и вносим изменения в список точек маршрута
            $order_num = 1;
            $lastCityId = 0;

            // ... шаблон запроса
            $sql = 'UPDATE route_point
                      SET  distance = ?i, order_num = ?i
                    WHERE id = ?i';

            foreach ($routePoints as $routePoint)
            {
                $distance = $distanceList->GetDistanceFromList($lastCityId, $routePoint->cityId);
                $db->query($sql, $distance, $order_num++, $routePoint->id);

                $lastCityId = $routePoint->cityId;
            }


            // 7. Получаем обновлённый маршрут
            $routePointList = CalculateRouteWebService::GetRouteData($accountId, $userTokenId, $db);

            // 8. возвращаем ответ клиенту
            $responseData = new AjaxRoutePointPlaceAndRoutePointList();
            $responseData->routePointPlace = $data;
            $responseData->routePointList = $routePointList;
            $response = new AjaxServerResponse(200, '', '', $responseData);
            sendHTTPStatus(200);
            header('Content-type: application/json');
            echo json_encode($response);

        }
        catch(Exception $ex)
        {
            Log::writeSqlExeption($db, $ex);
            $this->returnError(500, array(1), $data);
        }

    }

    // Удаляем задачу из маршрута
    public function onDelete($args, $data)
    {
        // $data = AjaxIdsList

        $idsInSqlString = implode(',', $data->ids);

        $accountId = null;
        $userTokenId = null;
        CurrentUser::FillUserIdentities($accountId, $userTokenId);


        $db = SqlFactory::getSql();

        try
        {
            // 1. получаем id маршрута для пользователя
            $route_id = RouteHelper::GetRouteId($accountId, $userTokenId, $db);

            if(false == $route_id)
            {
                // возвращаем ошибку
                $this->returnError(400, array(1014), $data);
                return;
            }

            // 2. удаляем указанные маршруты
            $sql = 'DELETE FROM route_point WHERE route_id = ?i AND cargo_selected_id IN (?p)';
            $db->query($sql, $route_id, $idsInSqlString);


            // 3. корректируем дистанцию 1-й точки в маршруте
            // ... получаем идентификатор 1-й точки маршрута
            $sql = 'SELECT id FROM route_point
                    WHERE route_id = ?i
                    ORDER BY order_num LIMIT 1';

            $route_point_id = $db->getOne($sql, $route_id);

            // ... если идентификатор получен, то обнуляем дистанцию у 1-й точки маршрута
            if(0 < $route_point_id)
            {
                $sql = 'UPDATE route_point SET distance = 0 WHERE id = ?i';
                $db->query($sql, $route_point_id);
            }

            // 4. Получаем обновлённый маршрут
            $routePointList = CalculateRouteWebService::GetRouteData($accountId, $userTokenId, $db);

            // 5. возвращаем ответ клиенту
            $responseData = new AjaxIdsListAndRoutePointList();
            $responseData->idsList = $data;
            $responseData->routePointList = $routePointList;
            $response = new AjaxServerResponse(200, '', '', $responseData);
            sendHTTPStatus(200);
            header('Content-type: application/json');
            echo json_encode($response);

        }
        catch(Exception $ex)
        {
            Log::writeSqlExeption($db, $ex);
            $this->returnError(500, array(1), $data);
        }
    }


}