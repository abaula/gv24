<?php
/**
 * Created by JetBrains PhpStorm.
 * User: Anton
 * Date: 21.03.15
 * Time: 22:02
 * To change this template use File | Settings | File Templates.
 */

require_once("WebServBase.module");
require_once("Headers.module");
require_once("Contract.module");
require_once("RouteHelper.module");
require_once("CargoSelectedHelper.module");
require_once("RouteCalculator.module");

class CalculateRouteWebService extends WebServBase
{

    public function onGet($args)
    {
        // получаем данные созданного маршрута
        $accountId = null;
        $userTokenId = null;
        CurrentUser::FillUserIdentities($accountId, $userTokenId);

        $db = SqlFactory::getSql();

        try
        {
            $routePointList = self::GetRouteData($accountId, $userTokenId, $db);
            $cities = RouteHelper::GetUniqueStartCitiesFromAjaxRoutePointsArray($routePointList->routePoints);
            $citiesList = new AjaxCityList($cities);

            $responseData = new AjaxRoutePointListAndCitiesList();
            $responseData->routePointList = $routePointList;
            $responseData->routeStartCitiesList = $citiesList;
            $response = new AjaxServerResponse(200, '', '', $responseData);
            sendHTTPStatus(200);
            header('Content-type: application/json');
            echo json_encode($response);

        }
        catch(Exception $ex)
        {
            Log::writeSqlExeption($db, $ex);
            $this->returnError(500, array(1));
        }
    }

    public function onPost($args, $data)
    {
        // пересчитываем данные маршрута
        $accountId = null;
        $userTokenId = null;
        CurrentUser::FillUserIdentities($accountId, $userTokenId);

        $db = SqlFactory::getSql();

        try
        {
            // AjaxCalculateOptions
            $options = $data;

            // 1. пересчитываем маршрут
            $route = self::CalculateRoute($accountId, $userTokenId, $options, $db);

            // 2. обновляем маршрут пользователя
            self::UpdateRoute($accountId, $userTokenId, $route, $db);

            // 3. получаем данные марщрута
            $routePointList = self::GetRouteData($accountId, $userTokenId, $db);

            // 4. получаем список городов маршрута
            $cities = RouteHelper::GetUniqueStartCitiesFromAjaxRoutePointsArray($routePointList->routePoints);
            $citiesList = new AjaxCityList($cities);

            // 5. возвращаем данные клиенту
            $responseData = new AjaxRoutePointListAndCitiesList();
            $responseData->routePointList = $routePointList;
            $responseData->routeStartCitiesList = $citiesList;

            $response = new AjaxServerResponse(200, '', '', $responseData);
            sendHTTPStatus(200);
            header('Content-type: application/json');
            echo json_encode($response);

        }
        catch(Exception $ex)
        {
            Log::writeSqlExeption($db, $ex);
            $this->returnError(500, array(1));
        }
    }

    public function onPut($args, $data)
    {
        // HTTP/1.1 405 Method Not Allowed
        sendHTTPStatus(405);
        header('Allow: GET,POST');
    }

    public function onDelete($args, $data)
    {
        // HTTP/1.1 405 Method Not Allowed
        sendHTTPStatus(405);
        header('Allow: GET,POST');
    }

    static function GetRouteData($accountId, $userTokenId, $db)
    {
        $list = new AjaxRoutePointList();

        // 1. получаем идентификатор маршрута
        $routeId = RouteHelper::GetRouteId($accountId, $userTokenId, $db);

        // 2. получаем данные маршрута
        $sql = 'SELECT
                    RP.id AS route_point_id,
                    C.id AS cargo_id,
                    C.is_deleted AS cargo_is_deleted,
                    RP.distance AS route_point_distance,
                    RP.city_id,
                    GC.name AS city_name,
                    CASE RP.is_first_point_of_pair WHEN 1 THEN C.weight ELSE (- C.weight) END AS weight,
                    CASE RP.is_first_point_of_pair WHEN 1 THEN C.value ELSE (- C.value) END AS value,
                    CASE RP.is_first_point_of_pair WHEN 0 THEN C.cost ELSE 0 END AS cost,
                    CASE RP.is_first_point_of_pair WHEN 1 THEN C.ready_date ELSE null END AS ready_date
                FROM route_point RP
                    INNER JOIN geocities GC
                        ON GC.id = RP.city_id
                    INNER JOIN cargo_selected CS
                        ON CS.id = RP.cargo_selected_id
                    INNER JOIN cargo C
                        ON C.id = CS.cargo_id
                WHERE RP.route_id = ?i
                ORDER BY RP.order_num';

        $result = $db->query($sql, $routeId);

        if(0 < $db->numRows($result))
        {
            while($row = $db->fetch($result))
            {
                $entry = new AjaxRoutePoint
                (
                    $row['route_point_id'], $row['cargo_id'], $row['cargo_is_deleted'], $row['city_id'], $row['city_name'],
                    $row['route_point_distance'], $row['weight'], $row['value'], $row['cost'], $row['ready_date']
                );

                array_push($list->routePoints, $entry);
            }
        }

        return $list;
    }


    static function CalculateRoute($accountId, $userTokenId, $options, $db)
    {
        // 1. получаем идентификатор маршрута
        $routeId = RouteHelper::GetRouteId($accountId, $userTokenId, $db);

        // 2. получаем данные маршрута - TaskInfo[] в зависимости от настроек пользователя
        if($options->useCargoFromRoute)
            $routeTasksInfoList = RouteHelper::GetCargoInRouteData($routeId, $db);
        else
            $routeTasksInfoList = CargoSelectedHelper::GetSelectedCargoData($accountId, $userTokenId, $db);

        // 3. создаём список ограничений
        $conflictResolveCriteria = $options->conflictResolveCriteria == 'MaxProceeds' ? ConflictResolveCriteria::MaxProceeds : ConflictResolveCriteria::MaxProfit;
        $loadingStrategy = $options->loadingStrategy == 'SavingWeight' ? LoadingStrategy::SavingWeight : LoadingStrategy::SavingValue;
        $routeRestrictions = new RouteRestrictions($options->vehicleParams->maxValue, $options->vehicleParams->maxWeight, $conflictResolveCriteria, $loadingStrategy);

        // 4. создаём список заданий на перевозку - RouteTask, RouteTaskList
        $list = array();

        foreach($routeTasksInfoList as $routeTaskInfo)
        {
            $vertexA = new GVertex($routeTaskInfo->cityId1, $routeTaskInfo->city1Name, $routeTaskInfo->city1Latitude, $routeTaskInfo->city1Longitude);
            $vertexB = new GVertex($routeTaskInfo->cityId2, $routeTaskInfo->city2Name, $routeTaskInfo->city2Latitude, $routeTaskInfo->city2Longitude);
            $task = new RouteTask($routeTaskInfo->id, $routeTaskInfo->name, $vertexA, $vertexB, $routeTaskInfo->cost, $routeTaskInfo->value, $routeTaskInfo->weight, $routeTaskInfo->distance);
            array_push($list, $task);
        }

        $routeTaskList = new RouteTaskList();
        $routeTaskList->addRouteTasks($list);

        //print_r($routeTaskList);

        // 5. получаем список уникальных вершин для графа - GVertex[]
        $vertices = $routeTaskList->getVertices();

        //print_r($vertices);

        // 6. получаем список городов.
        // ВАЖНО: В текущей реализации id вершины = id города
        $cityIds = array();

        foreach($vertices as $vertex)
            array_push($cityIds, $vertex->getId());

        //print_r($cityIds);

        // 7. получаем дистанцию между городами
        $distanceList = GeoRouteHelper::GetDistanceList($cityIds, $db);

        //print_r($distanceList);

        // 8. создание массива рёбер для графа - GEdge[]
        // ВАЖНО: В текущей реализации id вершины = id города
        $edges = array();
        $edgeId = 1;

        foreach($distanceList->geoRouteDistanceList as $geoDistance)
        {
            $edge = new GEdge($edgeId++, '', $geoDistance->city1Id, $geoDistance->city2Id, $geoDistance->distance);
            array_push($edges, $edge);
        }

        // 9. создаём граф
        $graph = new UndirectedGraph();
        $graph->init($vertices, $edges);

        //print_r($graph);

        // 10. получаем вершину с которой начинается наш маршрут
        $startVertex = $vertices[$options->startCityId];

        //print_r($startVertex);

        // 11. расчитываем маршрут
        $calculator = new RouteCalculator($routeTaskList, $routeRestrictions, $graph);
        $calculator->calculateRoute($startVertex);
        // всегда получаем оптимальный маршрут рассчитанный без учёта обратного пути
        $route = $calculator->getRoute();

        //print_r($route);

        // 12. Возвращаем рассчитанный маршрут
        return $route;
    }


    static function UpdateRoute($accountId, $userTokenId, $routeData, $db)
    {
        // 1. получаем идентификатор маршрута
        $routeId = RouteHelper::GetRouteId($accountId, $userTokenId, $db);

        // 2. если маршрут отсутствует то создаём его
        if(1 > $routeId)
        {
            $routeId = RouteHelper::CreateRoute($accountId, $userTokenId, $db);
        }

        // 3. Удаляем данные маршрута
        RouteHelper::ClearRoute($routeId, $db);

        // 4. Вносим данные в маршрут

        // ... 4.1 создаём карту cargoId к cargoSelectedId
        CargoSelectedHelper::CreateMap($accountId, $userTokenId, $db);

        // ... 4.2 получаем список рёбер маршрута - RouteEntry[]
        $routes = $routeData->getEntries();

        //print_r($routes);

        // ... 4.3 обрабатываем данные каждого ребра маршрута
        $distance = 0;
        $num = 1;
        // ... шаблон запроса
        $sql = 'INSERT INTO route_point (route_id, cargo_selected_id, city_id, distance, is_first_point_of_pair, order_num)
                        VALUES (?i, ?i, ?i, ?i, ?i, ?i)';


        foreach($routes as $routeEntry)
        {
            $edge = $routeEntry->getEdge();
            $vertexA = $edge->getVertexA();
            $vertexB = $edge->getVertexB();

            // сохраняем все точки на загрузку
            // print_r($vertexA);
            // printf("%s\n", $vertexA->getId());

            // список загруженных грузов в точке А
            $vertexATasks = $routeEntry->getCommitedTasks();

            foreach($vertexATasks as $taskA)
            {
                // printf("\t%d\n", $taskA->getId());
                $cargoSelectedId = CargoSelectedHelper::GetCargoSelectedIdByCargoId($taskA->getId());
                $db->query($sql, $routeId, $cargoSelectedId, $vertexA->getId(), $distance, 1, $num++);

                // обнуляем дистанцию - дистанция указывается, только при смене города, т.е. для 1-го задания из точки А ребра
                $distance = 0;
            }

            // printf("%s\n", $vertexB->getId());

            // для первого груза в точке B указываем дистанцию
            $distance = $edge->getDistance();

            // список выгруженных грузов в точке B
            $vertexBTasks = $routeEntry->getFulfiledTasks();

            foreach($vertexBTasks as $taskB)
            {
                // printf("\t%d\n", $taskB->getId());
                $cargoSelectedId = CargoSelectedHelper::GetCargoSelectedIdByCargoId($taskB->getId());
                $db->query($sql, $routeId, $cargoSelectedId, $vertexB->getId(), $distance, 0, $num++);

                // обнуляем дистанцию - дистанция указывается, только при смене города, т.е. для 1-го задания из точки B ребра
                $distance = 0;
            }


            //print_r($routeEntry);
        }
    }

}