<?php
/**
 * Created by JetBrains PhpStorm.
 * User: Anton
 * Date: 28.04.15
 * Time: 14:00
 * To change this template use File | Settings | File Templates.
 */

require_once('GeoRouteHelper.module');




/*
Базовый класс для сущностей графа - вершины и ребра
*/
class GObject
{
    // уникальный номер объекта
    private $_id;
    // имя объекта
    private $_name;

    function construct($id, $name)
    {
        $this->_id = $id;
        $this->_name = $name;
    }

    function getId()
    {
        return $this->_id;
    }

    function getName()
    {
        return $this->_name;
    }

    function setName($value)
    {
        $this->_name = $value;
    }
}

/*
    Роль вершины для машрутов
    - разгрузка, погрузка, и разгрузка и погрузка
*/
class GVertexTaskRole
{
    const Undefined = 0;
    const Loading = 1;
    const Unloading = 2;
    const All = 3;
}

/*
    Способы принятия решений при конфликтах из-за ограничений накладываемых на маршрут
*/
class ConflictResolveCriteria
{
    // максимальная выручка
    const MaxProceeds = 0;
    // максимальная прибыльность = максимальная стоимость за километр пути
    const MaxProfit = 1;
}

/*
    Стратегия загрузки нескольких грузов - влияет на очерёдность загрузки нескольких грузов
*/
class LoadingStrategy
{
    // экономия веса
    const SavingWeight = 0;
    // экономия объёма
    const SavingValue = 1;
}

/*
   Вершина графа
*/
class GVertex extends GObject
{
    // Рёбра присоединённые к точке
    private $_edges;
    // Маршруты присоединённые к точке
    private $_routeTasks;
    // Географические координаты вершины
    private $_geoPoint;
    // Сумма ролей вершины для заданий в которые она входит
    private $_vertexTaskRole;

    function __construct($id, $name, $latitude, $longitude)
    {
        parent::construct($id, $name);
        $this->_geoPoint = new GEOPoint($latitude, $longitude);
        $this->_edges = array();
        $this->_routeTasks = array();
        $this->_vertexTaskRole = GVertexTaskRole::Undefined;
    }

    function getEdges()
    {
        return $this->_edges;
    }

    function getRouteTasks()
    {
        return $this->_routeTasks;
    }

    function getGeoPoint()
    {
        return $this->_geoPoint;
    }

    function isEqual($vertex)
    {
        return $this->getId() == $vertex->getId();
    }

    function addEdge($edge)
    {
        $this->_edges[$edge->getId()] = $edge;
    }

    function addRouteTask($routeTask)
    {
        $this->_routeTasks[$routeTask->getId()] = $routeTask;
    }

    // есть ли связанные задания для которых вершина выполняет указанную роль
    function hasRouteTaskRole($role)
    {
        if (GVertexTaskRole::Undefined == $this->_vertexTaskRole)
        {
            $tasks = $this->_routeTasks;

            foreach ($tasks as $task)
            {
                $isA = $task->getVertexA()->isEqual($this);
                $isB = $task->getVertexB()->isEqual($this);

                if ($isA)
                    $this->_vertexTaskRole |= GVertexTaskRole::Loading;

                if ($isB)
                    $this->_vertexTaskRole |= GVertexTaskRole::Unloading;
            }
        }

        return 0 < ($this->_vertexTaskRole & $role);
    }

    // возвращает те связанные задания для которых вершина выполняет указанную роль
    function getRouteTasksForRole($role)
    {
        $result = array();
        $tasks = $this->_routeTasks;

        foreach ($tasks as $task)
        {
            if ($role & GVertexTaskRole::Loading)
            {
                // выбираем задания, у которых вершина является началом маршрута (загрузка)
                $isA = $task->getVertexA()->isEqual($this);

                if ($isA)
                    array_push($result, $task);
            }
            else if ($role & GVertexTaskRole::Unloading)
            {
                // выбираем задания, у которых вершина является концом маршрута (разгрузка)
                $isB = $task->getVertexB()->isEqual($this);

                if ($isB)
                    array_push($result, $task);
            }
        }

        return $result;
    }

}

/*
   Ребро графа
*/
class GEdge extends GObject
{
    // Идентификаторы вершин ребра
    private $_verticesId;
    // Вершины ребра
    private $_vertices;
    // Расстояние (км)
    private $_distance;

    function __construct($id, $name, $vAId, $vBId, $distance)
    {
        parent::construct($id, $name);
        $this->_verticesId = array($vAId, $vBId);
        $this->_vertices = array();
        $this->_distance = $distance;
    }

    function addVertex($v)
    {
        array_push($this->_vertices, $v);
    }

    function getDistance()
    {
        return $this->_distance;
    }

    function isEqual($edge)
    {
        return $this->getId() == $edge->getId();
    }

    function getVertexId($getA)
    {
        return $getA ? $this->_verticesId[0] : $this->_verticesId[1];
    }

    function getAnotherVertex($v)
    {
        $result = null;

        if ($v == $this->_vertices[0])
            $result = $this->_vertices[1];
        else if ($v == $this->_vertices[1])
            $result = $this->_vertices[0];

        return $result;
    }

    function getVertexA()
    {
        return $this->_vertices[0];
    }

    function getVertexB()
    {
        return $this->_vertices[1];
    }

}

/*
Точка, содержащая географические координаты
*/
class GEOPoint
{
    private $_latitude;
    private $_longitude;

    function __construct($latitude, $longitude)
    {
        $this->_latitude = $latitude;
        $this->_longitude = $longitude;
    }

    function getLatitude()
    {
        return $this->_latitude;
    }

    function setLatitude($value)
    {
        $this->_latitude = $value;
    }

    function getLongitude()
    {
        return $this->_longitude;
    }

    function setLongitude($value)
    {
        $this->_longitude = $value;
    }

    function clonePoint()
    {
        $point = new GEOPoint($this->_latitude, $this->_longitude);
        return $point;
    }
}

/*
    Ненаправленный граф
*/
class UndirectedGraph
{
    private $_vertices;
    private $_edges;

    function __construct()
    {
        $this->_vertices = array();
        $this->_edges = array();
    }

    // инициализация внутренней структуры графа
    function init($vertices, $edges)
    {
        // сохраняем вершины
        foreach ($vertices as $vertex)
        {
            // сохраняем вершину
            $this->_vertices[$vertex->getId()] = $vertex;
        }

        //var_dump($this->_vertices);

        // сохраняем рёбра
        foreach ($edges as $edge)
        {
            // проставляем в рёбра ссылки на вершины
            $vertexA = $this->_vertices[$edge->getVertexId(true)];
            $edge->addVertex($vertexA);
            $vertexB = $this->_vertices[$edge->getVertexId(false)];
            $edge->addVertex($vertexB);

            // проставляем в вершины ссылки на ребро
            $vertexA->addEdge($edge);
            $vertexB->addEdge($edge);

            // сохраняем ребро
            $this->_edges[$edge->getId()] = $edge;
        }
    }

    function getEdges()
    {
        return $this->_edges;
    }
}


/*
    Задание на доставку груза, маршрут состоящий из 2-х точек, загрузки и выгрузки->
    Содержит данные о пункте отправления и назначения, о параметрах перевозимого груза включая стоимость
*/
class RouteTask
{
    // уникальный номер задания
    private $_id;
    // неуникальное название задания (например Смоленск - Москва)
    private $_name;
    // начальная точка, место отправления
    private $_vertexA;
    // конечная точка, место прибытия
    private $_vertexB;
    // стоимость
    private $_price;
    // объём груза
    private $_value;
    // масса груза
    private $_weight;
    // расстояние перевозки (по справочнику)
    private $_distance;

    function __construct($id, $name, $vertexA, $vertexB, $price, $value, $weight, $distance)
    {
        $this->_id = $id;
        $this->_name = $name;
        $this->_vertexA = $vertexA;
        $this->_vertexB = $vertexB;
        $this->_price = $price;
        $this->_value = $value;
        $this->_weight = $weight;
        $this->_distance = $distance;
    }

    function getId()
    {
        return $this->_id;
    }

    function getName()
    {
        return $this->_name;
    }

    function getVertexA()
    {
        return $this->_vertexA;
    }

    function setVertexA($value)
    {
        $this->_vertexA = $value;
    }

    function getVertexB()
    {
        return $this->_vertexB;
    }

    function setVertexB($value)
    {
        $this->_vertexB = $value;
    }


    function getPrice()
    {
        return $this->_price;
    }

    function getValue()
    {
        return $this->_value;
    }

    function getWeight()
    {
        return $this->_weight;
    }

    function getDistance()
    {
        return $this->_distance;
    }

    function isVertexA($vertex)
    {
        return $this->_vertexA->getId() == $vertex->getId();
    }

    function hasVertex($vertex)
    {
        return $this->_vertexA->getId() == $vertex->getId() || $this->_vertexB->getId() == $vertex->getId();
    }

    // Устанавливает связь задания на перевозку с обеими вершинами
    function bindVerticesToThisTask()
    {
        $this->_vertexA->addRouteTask($this);
        $this->_vertexB->addRouteTask($this);
    }

    // возвращает стоимость за 1 км пути
    function getProfit()
    {
        return $this->_price / $this->_distance;
    }
}

/*
Список заданий на перевозку RouteTask, которые подлежат обработке
В отличии от простого массива предоставляет сервисные функции
*/
class RouteTaskList
{
    private $_tasks;
    private $_vertices;

    function __construct()
    {
        $this->_tasks = array();
        $this->_vertices = array();
    }

    // инициализирует список заданий на перевозку
    function addRouteTasks($tasks)
    {
        foreach ($tasks as $task)
        {
            // сохраняем вершины без дублей
            $this->_saveVertex($task, $task->getVertexA(), true);
            $this->_saveVertex($task, $task->getVertexB(), false);

            // связываем вершины с заданием
            $task->bindVerticesToThisTask();

            // сохраняем задание
            $this->_tasks[$task->getId()] = $task;
        }
    }

    // сохраняет только уникальные вершины без дублей
    // при необходимости подменяет вершины в задании
    private function _saveVertex($task, $vertex, $isA)
    {
        if (array_key_exists($vertex->getId(), $this->_vertices))
        {
            // вершина с данным Id уже сохранена ранее, поэтому
            // подменяем вершину в задании на сохранённую ранее
            $savedVertex = $this->_vertices[$vertex->getId()];

            if ($isA)
                $task->setVertexA($savedVertex);
            else
                $task->setVertexB($savedVertex);
        }
        else
        {
            // сохраняем вершину
            $this->_vertices[$vertex->getId()] = $vertex;
        }

    }

    // возвращает массив вершин
    function getVertices()
    {
        return $this->_vertices;
    }
}

/*
Ограничения накладываемые на маршрут
*/
class RouteRestrictions
{
    // максимальный объём
    private $_maxValue;
    // максимальный вес
    private $_maxWeight;
    // решение принимаемое при конфликте (если для загрузки одновременно доступны несколько грузов, суммарный вес или объём которых больше установленных максимальных ограничений, нужно от каких-то отказаться)
    private $_conflictResolveCriteria;
    // стратегия загрузки нескольких грузов по умолчанию
    private $_loadingStrategy;

    function __construct($maxValue, $maxWeight, $conflictResolveCriteria, $loadingStrategy)
    {
        $this->_maxValue = $maxValue;
        $this->_maxWeight = $maxWeight;
        $this->_conflictResolveCriteria = $conflictResolveCriteria;
        $this->_loadingStrategy = $loadingStrategy;
    }

    function getMaxValue()
    {
        return $this->_maxValue;
    }

    function getMaxWeight()
    {
        return $this->_maxWeight;
    }

    function getConflictResolveCriteria()
    {
        return $this->_conflictResolveCriteria;
    }

    function getLoadingStrategy()
    {
        return $this->_loadingStrategy;
    }

}




/*
Расчитанный оптимальный маршрут
Содержит списки включенных заданий на перевозку и список исключённых заданий,
тех, которые не подошли по параметрам к условиям ограничения RouteRestrictions->
Содержит обшую протяжённость маршрута и другую справочную информацию
*/
class Route
{
    // исполненные задания на перевозку
    private $_fulfiledTasks;
    // неисполненные задания на перевозку
    private $_excludedTasks;
    // массив частей маршрута
    private $_entries;
    // обратный путь маршрута, из конца в начало
    private $_wayBackEntry;
    // суммарная дистанция маршрута
    private $_sumDistance;
    // суммараная выручка
    private $_sumProceeds;
    // суммарный объём груза в маршруте
    private $_sumValue;
    // суммарный вес груза в маршруте
    private $_sumWeight;
    // суммарное исходное расстрояние для выполненных задач
    private $_fulfiledTasksDistance;
    // суммарное исходное расстояние для отложенных задач
    private $_excludedTasksDistance;
    // суммарное исходное расстояние для всех задач
    private $_allTasksDistance;

    function __construct()
    {
        $this->_fulfiledTasks = array();
        $this->_excludedTasks = array();
        $this->_entries = array();
        $this->_wayBackEntry = null;
        $this->_sumDistance = 0;
        $this->_sumProceeds = 0;
        $this->_sumValue = 0;
        $this->_sumWeight = 0;
        $this->_fulfiledTasksDistance = -1;
        $this->_excludedTasksDistance = -1;
        $this->_allTasksDistance = -1;    
    }

    function getFulfiledTasks()
    {
        return $this->_fulfiledTasks;
    }

    function getExcludedTasks()
    {
        return $this->_excludedTasks;
    }

    function getEntries()
    {
        return $this->_entries;
    }

    function getWayBackEntry()
    {
        return $this->_wayBackEntry;
    }

    function setWayBackEntry($value)
    {
        $this->_wayBackEntry = $value;
    }

    // возвращает дистанцию маршрута без дороги назад
    function getDistanse()
    {
        return $this->_sumDistance;
    }

    // возвращает дистанцию маршрута с дорогой назад
    function getDistanseWithWayBack()
    {
        return $this->_sumDistance + $this->_wayBackEntry->getEdge()->getDistance();
    }

    // возвращает выручку маршрута
    function getProceeds()
    {
        return $this->_sumProceeds;
    }


    // возвращает общий объём груза в маршруте
    function getValue()
    {
        return $this->_sumValue;
    }

    // возвращает общий вес груза в маршруте
    function getWeight()
    {
        return $this->_sumWeight;
    }

    // получить 1-ю вершину маршрута
    function getStartVertex()
    {
        if (1 > count($this->_entries))
            return null;

        // получаем первое ребро маршрута
        $entry = $this->_entries[0];
        // получаем все принятые задания в ребре маршрута
        $tasks = $entry->getCommitedTasks();
        // получаем индекс первого принятого задания в ребре маршрута
        $index = count($tasks) - 1;
        // получаем первое задание в маршруте
        $firstTask = $tasks[$index];

        return $firstTask->getVertexA();

    }

    // получить последнюю вершину маршрута
    function getEndVertex()
    {

        if (1 > count($this->_fulfiledTasks))
            return null;

        // получаем индекс послденего исполненного задания в маршруте
        $index = count($this->_fulfiledTasks) - 1;
        // получаем последнее исполненное задание в маршруте
        $endTask = $this->_fulfiledTasks[$index];

        return $endTask->getVertexB();
    }

    // добавляем часть маршрута
    function addEntry($entry)
    {
        //////////////////////////////////////////
        // Расчитываем суммовые значения

        // рассчитываем перевезённый вес и объём, полученная сумму денег
        // добавляем выполненные задания в список
        $fulfiledTasks = $entry->getFulfiledTasks();

        foreach ($fulfiledTasks as $task)
        {
            $this->_sumProceeds += $task->getPrice();
            $this->_sumValue += $task->getValue();
            $this->_sumWeight += $task->getWeight();

            // добавляем выполненное задание в список
            array_push($this->_fulfiledTasks, $task);
        }

        // расстояние
        $edge = $entry->getEdge();
        $this->_sumDistance += $edge->getDistance();

        // сохраняем часть маршрута
        array_push($this->_entries, $entry);

        // добавляем исключённые задания в список
        $excludedTasks = $entry->getExcludedTasks();

        foreach ($excludedTasks as $task)
        {
            array_push($this->_excludedTasks, $task);
        }            
    }

    function getProfit($considerWayBack)
    {
        $distance = $this->_sumDistance;

        if ($considerWayBack)
            $distance += $this->_wayBackEntry->getEdge()->getDistance();

        return $this->_sumProceeds / $distance;
    }

    function getEfficiency($considerWayBack)
    {
        $numTasks = count($this->_fulfiledTasks);
        $profit = $this->getProfit($considerWayBack);
        return $numTasks * $profit;
    }

    // получить исходное расстояние для выполненных задач 
    function getFulfiledTasksDistance()
    {
        if (0 > $this->_fulfiledTasksDistance)
        {
            $this->_fulfiledTasksDistance = 0;

            foreach ($this->_fulfiledTasks as $task)
            {
                $this->_fulfiledTasksDistance += $task->getDistance();
            }
        }

        return $this->_fulfiledTasksDistance;
    }

    // получить исходное расстояние для отложенных задач 
    function getExcludedTasksDistance()
    {
        if (0 > $this->_excludedTasksDistance)
        {
            $this->_excludedTasksDistance = 0;

            foreach ($this->_excludedTasks as $task)
            {
                $this->_excludedTasksDistance += $task->getDistance();
            }
        }

        return $this->_excludedTasksDistance;
    }

    // получить исходное расстояние для всех задач 
    function getAllTasksDistance()
    {
        if (0 > $this->_allTasksDistance)
        {
            $this->_allTasksDistance = 0;
            $this->_allTasksDistance += $this->getFulfiledTasksDistance();
            $this->_allTasksDistance += $this->getExcludedTasksDistance();
        }

        return $this->_allTasksDistance;
    }

}

/*
Часть рассчитанного оптимального маршрута - один перегон между 2-я точками
*/
class RouteEntry
{
    // ребро графа - перегон между двумя точками
    private $_edge;
    // массив принятых в вершине А в работу заданий на перевозку
    private $_commitedTasks;
    // массив исключенных в вершине А заданий на перевозку
    private $_excludedTasks;
    // массив завершённых в вершине Б заданий на перевозку
    private $_fulfiledTasks;

    function __construct()
    {
        $this->_edge = null;
        $this->_commitedTasks = [];
        $this->_excludedTasks = [];
        $this->_fulfiledTasks = [];
    }

    function getEdge()
    {
        return $this->_edge;
    }

    function setEdge($value)
    {
        $this->_edge = $value;
    }

    function getCommitedTasks()
    {
        return $this->_commitedTasks;
    }

    function getFulfiledTasks()
    {
        return $this->_fulfiledTasks;
    }

    function getExcludedTasks()
    {
        return $this->_excludedTasks;
    }

    function addFulfiledTask($task)
    {
        array_push($this->_fulfiledTasks, $task);
    }

    function addCommitedTask($task)
    {
        array_push($this->_commitedTasks, $task);
    }

    function addExcludedTask($task)
    {
        array_push($this->_excludedTasks, $task);
    }

}

/*
    Класс "муравей" сущность модели расчёта оптимального маршрута на основе генетического алгоритма "Муравьиный алгоритм"
*/
class Ant
{
    // ссылка на объект класса RouteCalculator
    private $_calculator;
    // список посещённых вершин
    private $_visitedVertices;
    // список выполняемых в текущий момент заданий на перевозку
    private $_commitedTasks;
    // Размер эллипса, для поиска попутных точек маршрутов
    private $_ellipseSize;
    // коэффициент Alpha, влияет на выбор муравьём очередного ребра для перехода
    private $_alpha;
    // коэффициент Beta, влияет на выбор муравьём очередного ребра для перехода
    private $_beta;
    // данные о текущей загрузке муравья - вес
    private $_curWeight;
    // данные о текущей загрузке муравья - объём
    private $_curValue;
    // построенный маршрут
    private $_route;

    function __construct($calculator, $alpha, $beta)
    {
        $this->_calculator = $calculator;
        $this->_ellipseSize = 0.2;
        $this->_alpha = $alpha;
        $this->_beta = $beta;
        $this->_curWeight = 0;
        $this->_curValue = 0;
        $this->_route = new Route();

        $this->_commitedTasks = array();
        $this->_visitedVertices = array();

        // инициализируем генератор случайных чисел
        self::_initRandomizer();
    }

    // муравей ищет путь
    function run($vertex)
    {
        while (null != $vertex)
        {
            // обрабатываем событие посещения вершины A (загружаем муравья)
            $routeEntry = $this->_handleVertexAVisited($vertex);
            // отмечаем вершину как посещённую
            $this->_visitedVertices[$vertex->getId()] = $vertex;
            // получаем список возможных путей
            $edges = $this->_getAccessibleEdges($vertex);

            if (1 > count($edges))
            {
                // создаём путь домой и выходим
                $this->_addBackHomeEntry();
                break;
            }
            else
            {
                // получаем следующую вершину ребра маршрута
                $edge = $this->_selectEdgeToMove($vertex, $edges);
                $vertex = $edge->getAnotherVertex($vertex);
                // обрабатываем событие посещения вершины Б (разгружаем муравья)
                $this->_handleVertexBVisited($vertex, $edge, $routeEntry);
                // сохраняем часть маршрута
                $this->_route->addEntry($routeEntry);
            }
        }

        return true;
    }

    // Находится ли задание в работе
    private function _isRouteTaskCommited($task)
    {
        $commited = array_key_exists($task->getId(), $this->_commitedTasks);

        return $commited;
    }

    // добавляем отдельно в Route->Route отдельный Route->RouteEntry из последней точки маршрута к первой точке маршрута
    private function _addBackHomeEntry()
    {
        $startVertex = $this->_route->getStartVertex();
        $endVertex = $this->_route->getEndVertex();

        $edges = $endVertex->getEdges();

        foreach ($edges as $edge)
        {
            $anotherVertex = $edge->getAnotherVertex($endVertex);

            if ($anotherVertex->isEqual($startVertex))
            {
                $entry = new RouteEntry();
                $entry->setEdge($edge);
                $this->_route->setWayBackEntry($entry);
                break;
            }
        }
    }

    function getRoute()
    {
        return $this->_route;
    }

    // обработка события загрузки муравья, принятые к исполнению задания сохраняются в списке
    // если объём загрузки превышает лимиты, обрабатывает конфликт и помещает конфликтные маршруты в список Route->RouteEntry->_excludedTasks
    private function _handleVertexAVisited($vertex)
    {
        $entry = new RouteEntry();

        ///////////////////////////////////////////////////////////
        // выбираем все задания, для которых данная вершина является начальной точкой перевозки
        $selectedTaskList = array();

        $vertexTasks = $vertex->getRouteTasks();

        //print_r($vertex);
        //exit();

        $valueToLoad = 0;
        $weightToLoad = 0;

        foreach ($vertexTasks as $task)
        {
            if ($task->getVertexA()->isEqual($vertex))
            {

                $selectedTaskList[$task->getId()] = $task;
                // подсчитываем суммарные значения груза подлежащего загрузке
                $valueToLoad += $task->getValue();
                $weightToLoad += $task->getWeight();
            }
        }

        //print_r($selectedTaskList);
        //exit();

        $selectedTasks = array_values($selectedTaskList);

        ///////////////////////////////////////////////////////////
        // проверяем наличие конфликта по объёму и весу
        $valueLimit = $this->_calculator->getRestrictions()->getMaxValue();
        $weightLimit = $this->_calculator->getRestrictions()->getMaxWeight();

        // расчитываем значения перевозимого муравьём объёма и веса после погрузки всех заданий
        $valueAfterLoad = $this->_curValue + $valueToLoad;
        $weightAfterLoad = $this->_curWeight + $weightToLoad;

        if ($valueAfterLoad > $valueLimit || $weightAfterLoad > $weightLimit)
        {
            // обрабатываем конфликт
            $commitedTasks = $this->_resolveLoadingConflictByCriteria($selectedTasks);

            // если не удалось ничего погрузить по правилам разрешения конфликтов, то пытаемся погрузить хоть что-нибудь
            if (1 > count($commitedTasks))
            {
                $commitedTasks = $this->_resolveLoadingConflictByLoadingStrategy($selectedTasks);
            }

            // удаляем все принятые задания из общего списка заданий, в итоге в нём останутся только не принятые задания
            foreach ($commitedTasks as $task)
            {
                unset($selectedTaskList[$task->getId()]);
            }

            // после разрешения кофликта вносим в список все исключённые задания
            foreach ($selectedTaskList as $task)
            {
                $entry->addExcludedTask($task);
            }

            // правим ссылку на список принятых в работу заданий для дальнейшего использования
            $selectedTasks = $commitedTasks;
        }


        // принимаем в работу все задания, которые остались после обработки конфликта
        $valueToLoad = 0;
        $weightToLoad = 0;

        foreach ($selectedTasks as $task)
        {
            // отмечаем принятые в работы задания
            $this->_commitedTasks[$task->getId()] = $task;
            // отмечаем принятые в работы задания в части маршрута
            $entry->addCommitedTask($task);

            $valueToLoad += $task->getValue();
            $weightToLoad += $task->getWeight();
        }

        // обновляем текущие вес и объём перевозимые муравьём
        $this->_curValue += $valueToLoad;
        $this->_curWeight += $weightToLoad;

        return $entry;
    }


    // обработка события разгрузки муравья
    private function _handleVertexBVisited($vertex, $edge, $routeEntry)
    {
        // сохраняем ребро
        $routeEntry->setEdge($edge);

        ///////////////////////////////////////////////////////////
        // выбираем все задания, для которых данная вершина является конечной точкой перевозки
        // помещаем их в список выполненных заданий и разгружаем муравья
        $vertexTasks = $vertex->getRouteTasks();
        $valueToUnload = 0;
        $weightToUnload = 0;

        foreach ($vertexTasks as $task)
        {
            if ($task->getVertexB()->isEqual($vertex))
            {
                // если задание не было принято в работу, то пропускаем его
                if (false == array_key_exists($task->getId(), $this->_commitedTasks))
                    continue;

                // вносим в маршрут только те задания, которые были приняты в работу

                // удаляем принятое ранее в работу задание из списка
                unset($this->_commitedTasks[$task->getId()]);
                // вносим выполненное задание в часть маршрута
                $routeEntry->addFulfiledTask($task);
                // уменьшаем текущие значения загрузки муравья
                $this->_curValue -= $task->getValue();
                $this->_curWeight -= $task->getWeight();
            }
        }
    }


    // разрешаем конфликт при загрузке согласно установленным правилам, возвращаем задания, которые можно принять в работу
    private function _resolveLoadingConflictByCriteria($tasks)
    {
        // получаем правила
        $criteria = $this->_calculator->getRestrictions()->getConflictResolveCriteria();

        // сортируем по убыванию максимальной выручки
        if (ConflictResolveCriteria::MaxProceeds == $criteria)
            usort($tasks, 'Ant::_compareTaskForProceeds');

        // сортируем по убыванию максимальной стоимости за 1 км пути (максимальная прибыльность)
        if (ConflictResolveCriteria::MaxProfit == $criteria)
            usort($tasks, 'Ant::_compareTaskForProfit');

        // получаем список заданий которые можно взять в работу
        $acceptableTasks = $this->_pickupTasksWithLimits($tasks);

        return $acceptableTasks;
    }

    // разрешаем конфликт при загрузке согласно стратегии загрузки, возвращаем задания, которые можно принять в работу
    private function _resolveLoadingConflictByLoadingStrategy($tasks)
    {
        // получаем правила
        $strategy = $this->_calculator->getRestrictions()->getLoadingStrategy();

        // сортируем по возрастанию объёма
        if (LoadingStrategy::SavingValue == $strategy)
            usort($tasks, 'Ant::_compareTaskForSaveValue');

        // сортируем по возрастанию массы
        if (LoadingStrategy::SavingWeight == $strategy)
            usort($tasks, 'Ant::_compareTaskForSaveWeight');

        // получаем список заданий которые можно взять в работу
        $acceptableTasks = $this->_pickupTasksWithLimits($tasks);

        return $acceptableTasks;
    }

    // выбираем задачи в соответствии с установленным лимитом
    private function _pickupTasksWithLimits($tasks)
    {
        // рассчитываем лимиты на погрузку
        $valueLimit = $this->_calculator->getRestrictions()->getMaxValue();
        $weightLimit = $this->_calculator->getRestrictions()->getMaxWeight();
        $valueLimit -= $this->_curValue;
        $weightLimit -= $this->_curWeight;

        $result = array();

        foreach ($tasks as $task)
        {
            $valueLimit -= $task->getValue();
            $weightLimit -= $task->getWeight();

            // если превысили лимит, то останавливаемся
            if (0 > $valueLimit || 0 > $weightLimit)
                break;

            array_push($result, $task);
        }

        return $result;
    }




    // для сортировки заданий по критерию выручки - по убыванию
    private static function _compareTaskForProceeds($a, $b)
    {
        if ($a->getPrice() < $b->getPrice())
            return 1;

        if ($a->getPrice() > $b->getPrice())
            return -1;

        return 0;
    }

    // для сортировки заданий по критерию прибыльности - по убыванию
    private static function _compareTaskForProfit($a, $b)
    {
        if ($a->getProfit() < $b->getProfit())
            return 1;

        if ($a->getProfit() > $b->getProfit())
            return -1;

        return 0;
    }

    // для сортировки заданий по критерию экономии объёма - по возрастанию
    private static function _compareTaskForSaveValue($a, $b)
    {
        if ($a->getValue() > $b->getValue())
            return 1;

        if ($a->getValue() < $b->getValue())
            return -1;

        return 0;
    }

    // для сортировки заданий по критерию экономии веса (грузоподьёмности) - по возрастанию
    private static function _compareTaskForSaveWeight($a, $b)
    {
        if ($a->getWeight() > $b->getWeight())
            return 1;

        if ($a->getWeight() < $b->getWeight())
            return -1;

        return 0;
    }


    /*
        Возвращает все доступные для перехода точки маршрута
        с учётом ограничений

    ==========================
    ???? МАНИФЕСТ ????

    1) Составляем список возможных рёбер ранжируя по статусам: от "возможный для перехода", до "под вопросом для перехода"
     - Возможный для перехода - все рёбра ведущие к вершинам, при прибытии в которые не будет пропущен груз->
     - Под вопросом для перехода - все рёбра ведущие к вершинам при прибытии в которые будет пропущен груз->

    2) Если в списке нет вершин "возможный для перехода", то оставляем только одно ребро, переход по которому приведёт к минимальным потерям
    относительно других возможных переходов, а именно - эффективность маршрута начатого в этой вершине, должна быть больше чем эффективность пропущенного маршрута

    */
    private function _getAccessibleEdges($vertex)
    {
        $result = array();
        // список рёбер возможных для перехода
        $arr1 = array();
        // список рёбер под вопросом для перехода
        $arr2 = array();

        ////////////////////////////////////////////////////////
        // добавляем в результат доступные для посещения рёбра
        $edges = $vertex->getEdges();

        foreach ($edges as $edge)
        {
            $nextV = $edge->getAnotherVertex($vertex);

            // исключаем вершины, которые уже посещали
            if (array_key_exists($nextV->getId(), $this->_visitedVertices))
                continue;

            // для кажого ребра определены 2 возможных состояния после перехода по ребру:
            // 1) маршруты пропущены не будут
            // 1->1) можно выгрузить груз
            $canUnload = false;
            // 1->2) можно загрузить груз полностью
            $canLoadAll = false;
            // 2) будут пропущены маршруты
            // 2->1) можно загрузить груз частично
            $canLoadPart = false;
            // 2->2) приедем в конец маршрута задачи не посетив её начало
            $skipRoute = false;

            // лимиты на погрузку
            $valueLimit = $this->_calculator->getRestrictions()->getMaxValue();
            $weightLimit = $this->_calculator->getRestrictions()->getMaxWeight();

            // загрузка накапливается итогом
            $valueAfterLoad = 0;
            $weightAfterLoad = 0;

            // получаем список заданий для вершины перехода
            $vertexTasks = $nextV->getRouteTasks();

            foreach ($vertexTasks as $task)
            {
                //////////////////////////////////////////////////
                // сможем ли выгрузить груз в вершине перехода?
                if ($task->getVertexB()->isEqual($nextV))
                {
                    if ($this->_isRouteTaskCommited($task))
                        $canUnload = true;
                    else
                        $skipRoute = true;
                }

                //////////////////////////////////////////////////
                // сможем ли принять груз в вершине перехода?
                if ($task->getVertexA()->isEqual($nextV))
                {
                    // будем грузится в вершине, узнаем превысим лимиты или нет
                    $valueAfterLoad += $this->_curValue + $task->getValue();
                    $weightAfterLoad += $this->_curWeight + $task->getWeight();

                    if ($valueAfterLoad <= $valueLimit && $weightAfterLoad <= $weightLimit)
                    {
                        $canLoadAll = true;
                        $canLoadPart = false;
                    }
                    else
                    {
                        if ($canLoadAll)
                            $canLoadPart = true;

                        $canLoadAll = false;
                    }
                }
            }

            // можем загрузиться или разгрузиться ничего не пропустив
            if (($canLoadAll || $canUnload) && !$skipRoute)
                array_push($arr1, $edge);
            // можем загрузиться или разгрузиться пропустив маршрут
            else if (($canLoadAll || $canUnload) && $skipRoute)
                array_push($arr2, $edge);
            // можем загрузиться частично, а значит пропускаем маршрут
            else if ($canLoadPart)
                array_push($arr2, $edge);
        }

        // формируем результат
        if (0 < count($arr1))
            $result = $arr1;
        else if(0 < count($arr2))
        {
            $effEdge = $this->_getEffectiveEdge($vertex, $arr2);
            array_push($result, $effEdge);
        }

        return $result;
    }

    // выбираем ребро с наибольшей эффективностью из возможных, согласно установленных правил разрешения конфликтов
    private function _getEffectiveEdge($vertex, $edges)
    {
        $result = null;
        // сначала присваиваем самое малое значение
        $criteriaMaxValue = ~PHP_INT_MAX;

        foreach ($edges as $edge)
        {
            $nextV = $edge->getAnotherVertex($vertex);
            $criteriaValue = $this->_getProfitForVertex($nextV);

            if ($criteriaValue > $criteriaMaxValue)
            {
                $criteriaMaxValue = $criteriaValue;
                $result = $edge;
            }
        }

        return $result;
    }

    // получить оценку выгоды посещения вершины
    // рассчитывается как сумма выгод или выручки (в зависитмости от настроек разрешения конфликтов) всех заданий, которые могут быть начаты в вершине за вычетом
    // сумма выгод или выручки всех заданий, которые будут пропущены из за посещения вершины
    private function _getProfitForVertex($vertex)
    {
        $result = 0;
        $confResolveCriteria = $this->_calculator->getRestrictions()->getConflictResolveCriteria();

        // получаем список заданий для вершины перехода
        $vertexTasks = $vertex->getRouteTasks();

        foreach ($vertexTasks as $task)
        {
            $curValue = 0;

            if (ConflictResolveCriteria::MaxProceeds == $confResolveCriteria)
                $curValue = $task->getPrice();
            else if (ConflictResolveCriteria::MaxProfit == $confResolveCriteria)
                $curValue = $task->getProfit();

            if ($task->getVertexA()->isEqual($vertex))
            {
                $result += $curValue;
            }
            else if ($task->getVertexB()->isEqual($vertex))
            {
                // если задание не в работе, значит мы его пропустим посетив указанную вершину
                if (!$this->_isRouteTaskCommited($task))
                    $result -= $curValue;
            }
        }

        return $result;
    }

    private static function _initRandomizer()
    {
        mt_srand(crc32(microtime()));
    }

    private static function _getRandFloat()
    {
        return mt_rand() / mt_getrandmax();
    }


    // выбираем следующее ребро по которому будем двигаться
    private function _selectEdgeToMove($vertex, $edges)
    {
        $pheromones = $this->_calculator->getPheromones();

        // расчитываем числители
        $numerators = array();
        $denominator = 0;

        foreach ($edges as $edge)
        {
            $pheromoneE = $pheromones[$edge->getId()];

            //////////////////////////////////////
            // расчитаем вес вершины
            // Правило: чем меньше вес вершины, тем больше шансов она получает при выборе
            $edgeWeight = $edge->getDistance();

            // учитываем приоритет вершины (3 - самый высокий приоритет)
            // 3 = могу разгрузится и взять груз
            // 2 = могу только взять груз
            // 1 = могу только разгрузиться
            $nextVertex = $edge->getAnotherVertex($vertex);

            if ($nextVertex->hasRouteTaskRole(GVertexTaskRole::All))
            {
                $edgeWeight /= 3;
            }
            else if ($nextVertex->hasRouteTaskRole(GVertexTaskRole::Loading))
            {
                $edgeWeight /= 2;
            }

            $a1 = pow($pheromoneE, $this->_alpha);
            $a2 = 1 / pow($edgeWeight, $this->_beta);
            $numerator = $a1 + $a2;

            array_push($numerators, $numerator);
            $denominator += $numerator;
        }

        ////////////////////////////////////////////
        // рассчитываем возможности для каждого ребра (сумма всех возможностей ~ 1->0, +- погрешность при операциях с плавающей точкой)

        $possibilities = array();

        foreach ($numerators as $numerator)
        {
            $pos = $numerator / $denominator;
            array_push($possibilities, $pos);
        }

        //////////////////////////////////////////////
        // Теперь кидаем кубик и смотрим куда он попал

        $randNum = self::_getRandFloat();
        // По умолчанию выбираем последнюю вершину в массиве edges (нивелируем погрешность при операциях с плавающей точкой)
        $choosenEdge = $edges[count($possibilities) - 1];
        $pos2 = 0;

        for ($i = 0; $i < count($possibilities); $i++)
        {
            $pos2 += $possibilities[$i];

            if ($randNum < $pos2)
            {
                $choosenEdge = $edges[$i];
                break;
            }
        }

        // Находим вершину с приоритетом, если такая есть
        // Вершина с приоритетом - точка разгрузки лежащая на пути выбранного ребра, точнее сказать рядом, в эллипсе установленной величины
        // Смысл такой - если едем мимо точки разгрузки, то нужно немного отклониться и разгрузить муравья
        $choosenEdge = $this->_getEdgeWithPriority($choosenEdge, $vertex, $edges);

        // TODO если заехали в попутную точку, то нужно решить отмечаем её как посещённую или нет
        // - если забрали весь груз из попутной точки и не пропустили из-за посещения не один маршрут, то снова заезжать не имеет смысла
        // - иначе (остался незагруженный груз, или точка в которой завершаются другие маршруты) не отмечаем эту точку как посещённую, позже заедем ещё раз

        return $choosenEdge;
    }

    private function _getEdgeWithPriority($choosenEdge, $startVertex, $edges)
    {
        $resultEdges = array();
        $endVertex = $choosenEdge->getAnotherVertex($startVertex);

        // создаём эллипс для поиска входящих точек
        $ellipse = new GEOEllipse($startVertex->getGeoPoint(), $endVertex->getGeoPoint(), $this->_ellipseSize);

        /////////////////////////////////////////////////////////////////////////
        // Если есть точки разгрузки в элипсе, то выберем ближайшую из найденных
        foreach ($edges as $edge)
        {
            if ($choosenEdge->getId() == $edge->getId())
                continue;

            $v = $edge->getAnotherVertex($startVertex);

            ///////////////////////////////////////
            /// Если вершина v - это конечная точка маршрута и начальная точка маршрута уже пройдена (муравей загружен),
            /// то проверяем находится ли эта вершина в элипсе
            ///
            if($v->hasRouteTaskRole(GVertexTaskRole::Unloading))
            {
                if ($this->_hasVertexAnyCommitedTask($v, GVertexTaskRole::Unloading))
                {
                    // находится ли точка в элипсе?
                    $inEllipse = $ellipse->isPointInEllipse($v->getGeoPoint());

                    if ($inEllipse)
                        array_push($resultEdges, $edge);
                }
            }
        }

        // Если нашли ребра с приоритетом, то выберем ближайшее
        if (0 < count($resultEdges))
            $choosenEdge = $this->_getMinDistanceEdge($resultEdges);

        return $choosenEdge;
    }

    // возвращает вершину с минимальным расстоянием
    private function _getMinDistanceEdge($edges)
    {
        $result = null;
        $distance = 0;

        foreach ($edges as $edge)
        {
            if (0 == $distance || $distance > $edge->getDistance())
            {
                $distance = $edge->getDistance();
                $result = $edge;
            }
        }

        return $result;
    }

    // проверяет что указанная вершина связана с задачами, которые выполняются в данный момент
    // связь вершины с задачами должна соответствовать указанной роли
    private function _hasVertexAnyCommitedTask($vertex, $vertexRole)
    {
        $result = false;
        $tasks = $vertex->getRouteTasksForRole($vertexRole);

        foreach ($tasks as $task)
        {
            $commited = $this->_isRouteTaskCommited($task);

            if ($commited)
            {
                $result = true;
                break;
            }
        }

        return $result;
    }

}

class GEOEllipse
{
    const DE2RA = 0.01745329252;
    const AVG_ERAD = 6371.0;

    private $_f1;
    private $_f2;
    private $_dPrc;
    private $_2a;


    function __construct($f1, $f2, $dPrc)
    {
        $this->_f1 = $f1->clonePoint();
        $this->_f2 = $f2->clonePoint();
        $this->_dPrc = $dPrc;
        $this->_2a = $this->_calculate2A();
    }

    private function _calculate2A()
    {
        $len2C = $this->_getGCDistance($this->_f1, $this->_f2);
        $delta = $len2C * $this->_dPrc;

        return $len2C + $delta;
    }

    private function _getGCDistance($p1, $p2)
    {
        $point1 = $p1->clonePoint();
        $point2 = $p2->clonePoint();

        $point1->setLatitude($point1->getLatitude() * self::DE2RA);
        $point1->setLongitude($point1->getLongitude() * self::DE2RA);

        $point2->setLatitude($point2->getLatitude() * self::DE2RA);
        $point2->setLongitude($point2->getLongitude() * self::DE2RA);

        $d = sin($point1->getLatitude())
            * sin($point2->getLatitude())
            + cos($point1->getLatitude())
            * cos($point2->getLatitude())
            * cos($point1->getLongitude() - $point2->getLongitude());

        return (self::AVG_ERAD * acos($d));
    }

    function isPointInEllipse($point)
    {
        $r1 = $this->_getGCDistance($this->_f1, $point);
        $r2 = $this->_getGCDistance($this->_f2, $point);
        $t2A = $r1 + $r2;

        return $t2A < $this->_2a;
    }
}


/*
    Алгоритм верхнего уровня управляющий расчётами оптимального маршрута

    ЦЕЛЬ РАСЧЁТА - найти маршрут по которому можно перевезти максимальное количество груза из указанного с максимальной эффективностью,
    которая посчитана как - выручка / дистанция.

    Общая формула определения эффективности построенного маршрута:
    Эффективность маршрута = количество выполненных заданий на перевозку * (общая выручка / общая дистанция)

*/
class RouteCalculator
{
    // список заданий на перевозку
    private $_taskList;
    // ограничения применяемые при поиске пути
    private $_restrictions;
    // граф
    private $_graph;
    // коэффециент сохранения следа при испарении
    private $_evaporationRate = 0.75;  //(испарение = 25%)
    // общее количество муравьёв в группе
    private $_antCount = 1000;
    // Алгоритм останавливает работу если указанное количество муравьёв подряд не смогли найти более короткий маршрут
    private $_stopAfter = 200;
    // список со значениями силы феромонового следа оставленного муравьями на посещённых рёбрах графа (edge.getId(), number)
    private $_edgePheromones;
    // построенный маршрут (отобран без учёта обратного пути)
    private $_route;
    // построенный маршрут (отобран с учётом обратного пути)
    private $_routeWithWayBack;

    function __construct($taskList, $restrictions, $graph)
    {
        $this->_taskList = $taskList;
        $this->_restrictions = $restrictions;
        $this->_graph = $graph;
        $this->_route = null;
        $this->_routeWithWayBack = null;
        $this->_edgePheromones = array();
    }

    function getTaskList()
    {
        return $this->_taskList;
    }

    function getRestrictions()
    {
        return $this->_restrictions;
    }

    function getGraph()
    {
        return $this->_graph;
    }

    function getRoute()
    {
        return $this->_route;
    }

    function getRouteWithWayBack()
    {
        return $this->_routeWithWayBack;
    }


    function calculateRoute($startVertex)
    {

        for ($a = 0; $a <= 5; $a++)
        {
            for ($b = 0; $b <= 5; $b++)
            {
                $this->_initPheromones();
                // счётчик неудачных попыток улучшить маршрут
                $missCount = 0;

                for ($i = 0; $i < $this->_antCount; $i++)
                {
                    // Испаряем часть феромонов с рёбер
                    if (1 < $i)
                        $this->_evaporatePheromones();

                    // Отправляем одного муравья в забег
                    $ant = new Ant($this, $a, $b);
                    $isRouteFound = $ant->run($startVertex);

                    // Если муравей нашёл путь, то сохраняем результат
                    if ($isRouteFound)
                    {
                        $route = $ant->getRoute();
                        // Добавляем феромоны на путь
                        $this->_addPheromones($route);

                        // пытаемся сохранить полученный маршрут
                        $better = $this->_tryUpdateRoute($route);

                        if ($better)
                        {
                            // обнуляем счётчик неудачных попыток улучшить маршрут
                            $missCount = 0;
                        }
                        else
                        {
                            // увеличиваем счётчик неудачных попыток улучшить маршрут
                            // и прекращаем дальнейшие попытки если превысили лимит
                            if (++$missCount > $this->_stopAfter)
                                break;
                        }
                    }
                }
            }
        }
    }

    // сохраняет полученный маршрут, если он эффективнее
    private function _tryUpdateRoute($route)
    {
        $result = false;

        // сохраняем более эффективный маршрут (эффективность посчитана без учёта обратного пути)
        if (null == $this->_route)
        {
            $this->_route = $route;
            $result = true;
        }
        else if ($route->getEfficiency(false) > $this->_route->getEfficiency(false))
        {
            $this->_route = $route;
            $result = true;
        }

        // сохраняем более эффективный маршрут (эффективность посчитана с учётом обратного пути)
        if (null == $this->_routeWithWayBack)
        {
            $this->_routeWithWayBack = $route;
            $result = true;
        }
        else if ($route->getEfficiency(true) > $this->_routeWithWayBack->getEfficiency(true))
        {
            $this->_routeWithWayBack = $route;
            $result = true;
        }

        return $result;
    }


    function getPheromones()
    {
        return $this->_edgePheromones;
    }

    // добавляем следы феромонов на рёбра графа по которым пробежал муравей и нашёл путь
    private function _addPheromones($route)
    {
        // чем больше денег заработали и короче найденный путь, тем больше феромонов добавляем
        // формула: эффективность = выручка / расстояние
        $distance = $route->getDistanse();
        $proceeds = $route->getProceeds();
        $pheromoneValue = $proceeds / $distance;
        $entries = $route->getEntries();

        foreach ($entries as $entry)
        {
            $edge = $entry->getEdge();
            $curValue = $this->_edgePheromones[$edge->getId()];
            $curValue += $pheromoneValue;
            $this->_edgePheromones[$edge->getId()] = $curValue;
        }

    }

    // обнуляет веса феромонового следа для всех рёбер графа
    private function _initPheromones()
    {
        $this->_edgePheromones = array();

        $edges = $this->_graph->getEdges();

        foreach ($edges as $edge)
        {
            $this->_edgePheromones[$edge->getId()] = 0.0;
        }
    }

    // испаряем часть феромонов
    private function _evaporatePheromones()
    {
        $keys = array_keys($this->_edgePheromones);

        foreach ($keys as $key)
        {
            $curValue = $this->_edgePheromones[$key];
            // испаряем установленную часть следа
            $curValue *= $this->_evaporationRate;
            $this->_edgePheromones[$key] = $curValue;
        }
    }
}